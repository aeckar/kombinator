package kombinator

import kombinator.symbols.*
import kombinator.symbols.Character
import kombinator.symbols.Junction
import kombinator.symbols.Switch
import kombinator.symbols.Symbol
import kombinator.symbols.ZeroLengthSymbol

/**
 * A meaningful value generated by the listener that visited this token.
 * Caller must specify the type of the object before use.
 */
@Suppress("UNCHECKED_CAST")
fun <T> QualifiedToken.payload() = (this as ContextFreeToken).payload as T

/**
 * Provides a scope with the receiver as this if the substring is not empty.
 */
inline fun <T : PossiblyEmptyToken> T.ifPresent(block: T.() -> Unit) {
    if (isPresent()) {
        block(this)
    }
}

/**
 * A meaningful portion of input.
 * @property id the name of the rule that produced this token,
 * or an automatically-generated numeric ID if produced by an implicitly-defined rule
 * @property substring the matching substring of input
 */
sealed interface Token {
    val id: String
    val substring: String

    fun flatten(): List<QualifiedToken>
}

/**
 * A non-literal token whose substring may be empty.
 */
sealed interface PossiblyEmptyToken : Token {
    /**
     * Same as calling substring.isEmpty(), but more idiomatic.
     * @return true if one or more tokens were matches
     */
    fun isPresent(): Boolean

    /**
     * Same as calling substring.isNotEmpty(), but more idiomatic.
     * @return true if no tokens were matched
     */
    fun isNotPresent(): Boolean
}

/**
 * A token that has been given a payload.
 *
 * API Note: Distinction from [Token] is necessary to prevent [payload]
 * from being called before the payload property is assigned a value.
 */
sealed interface QualifiedToken : Token

/**
 * A token matching a [single other token][match].
 * @see JunctionToken
 * @see OptionToken
 */
sealed interface SingleMatchToken : Token {
    val match: QualifiedToken

    /**
     * Asserts [match] is a [SequenceToken].
     * @return the single matched token
     * @throws TokenMismatchException the assertion fails
     */
    fun sequence(): QualifiedSequenceToken

    /**
     * Asserts [match] is a [JunctionToken].
     * @return the single matched token
     * @throws TokenMismatchException the assertion fails
     */
    fun junction(): QualifiedJunctionToken

    /**
     * Asserts [match] is a [SequenceToken].
     * @return the single matched token
     * @throws TokenMismatchException the assertion fails
     */
    fun multiple(): QualifiedMultipleToken

    /**
     * Asserts [match] is an [OptionToken].
     * @return the single matched token
     * @throws TokenMismatchException the assertion fails
     */
    fun option(): QualifiedOptionToken

    /**
     * Asserts [match] is a [StarToken].
     * @return the single matched token
     * @throws TokenMismatchException the assertion fails
     */
    fun star(): QualifiedStarToken

    /**
     * Asserts [match] is a [CharToken].
     * @return the single matched token
     * @throws TokenMismatchException the assertion fails
     */
    fun character(): QualifiedCharToken

    /**
     * Asserts [match] is a [StringToken].
     * @return the single matched token
     * @throws TokenMismatchException the assertion fails
     */
    fun text(): QualifiedStringToken

    /**
     * Asserts [match] is a [SwitchToken].
     * @return the single matched token
     * @throws TokenMismatchException the assertion fails
     */
    fun switch(): QualifiedSwitchToken
}

/**
 * A [SingleMatchToken] with a payload.
 */
sealed interface QualifiedSingleMatchToken : SingleMatchToken, QualifiedToken {
    override val match: QualifiedToken
}

/**
 * A token matching [multiple other tokens][matches].
 * @see SequenceToken
 * @see MultipleToken
 * @see StarToken
 */
sealed interface MultiMatchToken : Token {
    val matches: List<QualifiedToken>

    /**
     * Asserts that all [matches] are [SequenceToken]s.
     * @return the multiple matched tokens
     * @throws TokenMismatchException the assertion fails
     */
    fun sequences(): List<QualifiedSequenceToken>

    /**
     * Asserts that all [matches] are [JunctionToken]s.
     * @return the multiple matched tokens
     * @throws TokenMismatchException the assertion fails
     */
    fun junctions(): List<QualifiedJunctionToken>

    /**
     * Asserts that all [matches] are [MultipleToken]s.
     * @return the multiple matched tokens
     * @throws TokenMismatchException the assertion fails
     */
    fun multiples(): List<QualifiedMultipleToken>

    /**
     * Asserts that all [matches] are [OptionToken]s.
     * @return the multiple matched tokens
     * @throws TokenMismatchException the assertion fails
     */
    fun options(): List<QualifiedOptionToken>

    /**
     * Asserts that all [matches] are [StarToken]s.
     * @return the multiple matched tokens
     * @throws TokenMismatchException the assertion fails
     */
    fun stars(): List<QualifiedStarToken>

    /**
     * Asserts that all [matches] are [CharToken]s.
     * @return the multiple matched tokens
     * @throws TokenMismatchException the assertion fails
     */
    fun chars(): List<QualifiedCharToken>

    /**
     * Asserts that all [matches] are [StringToken]s.
     * @return the multiple matched tokens
     * @throws TokenMismatchException the assertion fails
     */
    fun strings(): List<QualifiedStringToken>

    /**
     * Asserts that all [matches] are [SwitchToken]s.
     * @return the multiple matched tokens
     * @throws TokenMismatchException the assertion fails
     */
    fun switches(): List<QualifiedSwitchToken>
}

/**
 * A [MultiMatchToken] with a payload.
 */
sealed interface QualifiedMultiMatchToken : MultiMatchToken, QualifiedToken {
    override val matches: List<QualifiedToken>
}

/**
 * A token created by a sequence of other rules.
 */
sealed interface SequenceToken : MultiMatchToken {
    /**
     * Asserts that the match at the given index is a [SequenceToken].
     * @return the matching token
     * @throws TokenMismatchException the assertion fails
     */
    fun sequenceAt(index: Int): QualifiedSequenceToken

    /**
     * Asserts that the match at the given index is a [JunctionToken].
     * @return the matching token
     * @throws TokenMismatchException the assertion fails
     */
    fun junctionAt(index: Int): QualifiedJunctionToken

    /**
     * Asserts that the match at the given index is a [MultipleToken].
     * @return the matching token
     * @throws TokenMismatchException the assertion fails
     */
    fun multipleAt(index: Int): QualifiedMultipleToken

    /**
     * Asserts that the match at the given index is an [OptionToken].
     * @return the matching token
     * @throws TokenMismatchException the assertion fails
     */
    fun optionAt(index: Int): QualifiedOptionToken

    /**
     * Asserts that the match at the given index is a [StarToken].
     * @return the matching token
     * @throws TokenMismatchException the assertion fails
     */
    fun starAt(index: Int): QualifiedStarToken

    /**
     * Asserts that the match at the given index is a [CharToken].
     * @return the matching token
     * @throws TokenMismatchException the assertion fails
     */
    fun charAt(index: Int): QualifiedCharToken

    /**
     * Asserts that the match at the given index is a [StringToken].
     * @return the matching token
     * @throws TokenMismatchException the assertion fails
     */
    fun stringAt(index: Int): QualifiedStringToken

    /**
     * Asserts that the match at the given index is a [SwitchToken].
     * @return the matching token
     * @throws TokenMismatchException the assertion fails
     */
    fun switchAt(index: Int): QualifiedSwitchToken

    /**
     * @return the match at the given index as a context-free [Token].
     */
    operator fun get(index: Int): QualifiedToken
}

/**
 * A [SequenceToken] with a payload.
 */
sealed interface QualifiedSequenceToken : SequenceToken, QualifiedMultiMatchToken

/**
 * A token created by using the '|' operator.
 */
sealed interface JunctionToken : SingleMatchToken {
    /**
     * @return the index of the rule that was matched
     */
    fun ordinal(): Int
}

/**
 * A [JunctionToken] with a payload.
 */
sealed interface QualifiedJunctionToken : JunctionToken, QualifiedSingleMatchToken

/**
 * A token created by using the '?' operator.
 */
sealed interface OptionToken : SingleMatchToken, PossiblyEmptyToken

/**
 * A [OptionToken] with a payload.
 */
sealed interface QualifiedOptionToken : OptionToken, QualifiedSingleMatchToken

/**
 * A token created by using the '+' operator.
 */
sealed interface MultipleToken : MultiMatchToken

/**
 * A [MultipleToken] with a payload.
 */
sealed interface QualifiedMultipleToken : MultipleToken, QualifiedMultiMatchToken

/**
 * A token created by using the '*' operator.
 */
sealed interface StarToken : MultiMatchToken, PossiblyEmptyToken

/**
 * A [StarToken] with a payload.
 */
sealed interface QualifiedStarToken : StarToken, QualifiedMultiMatchToken

/**
 * A token created by declaring a character literal (e.g. "a").
 */
sealed interface CharToken : Token {
    val charValue: Char
}

/**
 * A [CharToken] with a payload.
 */
sealed interface QualifiedCharToken : CharToken, QualifiedMultiMatchToken

/**
 * A token created by declaring a text literal (e.g. "abc").
 */
sealed interface StringToken : Token {
    val stringValue: String
    val length: Int
}

/**
 * A [StringToken] with a payload.
 */
sealed interface QualifiedStringToken : StringToken, QualifiedMultiMatchToken

/**
 * A token created by declaring a switch literal (e.g. \[abc]).
 */
sealed interface SwitchToken : Token {
    val charValue: Char
}

/**
 * A [SwitchToken] with a payload.
 */
sealed interface QualifiedSwitchToken : SwitchToken, QualifiedMultiMatchToken

internal class ContextFreeToken(
    var origin: Symbol,
    override val substring: String = "",
    val children: List<ContextFreeToken> = listOf(),
    private val ordinal: Int = 0
) :
    QualifiedSequenceToken, QualifiedJunctionToken, QualifiedOptionToken, QualifiedMultipleToken,
    QualifiedStarToken, QualifiedCharToken, QualifiedStringToken, QualifiedSwitchToken
{
    override val id get() = origin.id
    var payload: Any? = null

    override val match get() = children[0]
    override val length get() = substring.length
    override val charValue get() = substring.single()
    override val stringValue get() = substring
    override val matches get() = children

    override fun ordinal() = ordinal
    override fun isPresent() = children.isNotEmpty()
    override fun isNotPresent() = children.isEmpty()

    override fun sequenceAt(index: Int) = getAs<Sequence,QualifiedSequenceToken>(index)
    override fun junctionAt(index: Int) = getAs<Junction,QualifiedJunctionToken>(index)
    override fun multipleAt(index: Int) = getAs<Repetition,QualifiedMultipleToken>(index)
    override fun optionAt(index: Int) = getAs<Option,QualifiedOptionToken>(index)
    override fun starAt(index: Int) = getAs<RepeatOption,QualifiedStarToken>(index)
    override fun charAt(index: Int) = getAs<Character,QualifiedCharToken>(index)
    override fun stringAt(index: Int) = getAs<Text,QualifiedStringToken>(index)
    override fun switchAt(index: Int) = getAs<Switch,QualifiedSwitchToken>(index)

    override fun get(index: Int) = children[index]

    override fun sequences() = getAllAs<Sequence,QualifiedSequenceToken>()
    override fun junctions() = getAllAs<Junction,QualifiedJunctionToken>()
    override fun multiples() = getAllAs<Repetition,QualifiedMultipleToken>()
    override fun options() = getAllAs<Option,QualifiedOptionToken>()
    override fun stars() = getAllAs<RepeatOption,QualifiedStarToken>()
    override fun chars() = getAllAs<Character,QualifiedCharToken>()
    override fun strings() = getAllAs<Text,QualifiedStringToken>()
    override fun switches() = getAllAs<Switch,QualifiedSwitchToken>()

    override fun sequence() = getSingleAs<Sequence,QualifiedSequenceToken>()
    override fun junction() = getSingleAs<Junction,QualifiedJunctionToken>()
    override fun multiple() = getSingleAs<Repetition,QualifiedMultipleToken>()
    override fun option() = getSingleAs<Option,QualifiedOptionToken>()
    override fun star() = getSingleAs<RepeatOption,QualifiedStarToken>()
    override fun character() = getSingleAs<Character,QualifiedCharToken>()
    override fun text() = getSingleAs<Text,QualifiedStringToken>()
    override fun switch() = getSingleAs<Switch,QualifiedSwitchToken>()

    override fun flatten(): List<QualifiedToken> {
        return children.map { flatten() }.flatten()
    }

    fun <M : MutableState> walk(listeners: Map<String, Token.(M) -> Any?>, mutableState: M) {
        children.forEach { it.walk(listeners, mutableState) } // Visit every node in tree
        payload = listeners[id]?.let {
            it(this, mutableState).also {
                if (origin.isTerminal()) {
                    mutableState.position += substring.length
                }
            }
        } ?: when {
            origin.isMultiChild() -> children.map { it.payload }
            origin.isTerminal() -> children.getOrNull(0)?.payload
            else -> null    // Useful information for literals can be found in 'substring'
        }
    }

    private inline fun <reified S : Symbol, reified T : QualifiedToken> getAs(index: Int): T {
        return try {
            children[index].origin as S
            children[index] as T
        } catch (e: IndexOutOfBoundsException) {
            throw IndexOutOfBoundsException("Match at index $index in calling SequenceToken does not exist")
        } catch (e: TypeCastException) {
            val s = S::class.simpleName
            throw TokenMismatchException("Match at index $index in calling SequenceToken is not derived from a $s")
        }
    }

    @Suppress("UNCHECKED_CAST")
    private inline fun <reified S : Symbol, reified T : QualifiedToken> getAllAs(): List<T> {
        var failureLocation = 0
        return try {
            for (child in children) {
                child.origin as S
                ++failureLocation
            }
            children as List<T>
        } catch (e: TypeCastException) {
            throw TokenMismatchException("Match at index $failureLocation is not derived from a  ${S::class.simpleName}")
        }
    }

    private inline fun <reified S : Symbol, reified T : QualifiedToken> getSingleAs(): T {
        return try {
            children[0].origin as S
            children[0] as T
        } catch (e: TypeCastException) {
            throw TokenMismatchException("Match at index 0 is not derived from a  ${S::class.simpleName}")
        }
    }

    override fun toString() = "origin: $origin, payload: $payload"
    companion object {
        val NOTHING = ContextFreeToken(ZeroLengthSymbol().name("<nothing>"))
        val EMPTY = ContextFreeToken(ZeroLengthSymbol().name("<empty>"))
    }
}
